<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" type="text/css" href="style.css">
    <title>Scanner DoS Demo</title>
    <script>
        class Demo {
            constructor(container, text, parseFnGen, autoplayDelayMs = 300) {
                this.container = container;
                this.autoplayDelayMs = autoplayDelayMs;
                this.text = text;
                this.ix = 0;
                this.probeCount = 0;
                this.anchor = null;
                this.parseFnGen = parseFnGen;
                this.parseFn = parseFnGen();

                this.setupUI();
                this.updateUI();
            }

            setupUI() {
                const self = this;

                // Create display section
                this.section = document.createElement("section");
                for (const c of this.text) {
                    const charElt = document.createElement("char");
                    charElt.innerText = c;
                    this.section.appendChild(charElt);
                }
                this.container.appendChild(this.section);

                // Create form and its buttons
                const form = document.createElement("form");
                this.container.appendChild(form);

                this.indexSpan = document.createElement("span");
                this.indexSpan.classList.add("index");
                form.appendChild(this.indexSpan);

                this.counterSpan = document.createElement("span");
                this.counterSpan.classList.add("counter");
                form.appendChild(this.counterSpan);
                form.appendChild(document.createElement('br'));

                const nextButton = document.createElement("button");
                nextButton.innerText = "next";
                nextButton.type = "button";
                nextButton.addEventListener("click", () => self.next());
                form.appendChild(nextButton);

                const resetButton = document.createElement("button");
                resetButton.innerText = "reset";
                resetButton.type = "button";
                resetButton.addEventListener("click", () => self.reset());
                form.appendChild(resetButton);

                const autoplayButton = document.createElement("button");
                autoplayButton.innerText = "autoplay";
                autoplayButton.type = "button";
                autoplayButton.addEventListener("click", () => self.autoplay());
                form.appendChild(autoplayButton);
            }

            updateUI() {
                // first deactivate any existing active nodes
                for (const node of this.section.querySelectorAll("char.active")) {
                    node.classList.remove("active");
                }

                // activate node with given index
                const node = this.section.querySelector(`char:nth-child(${this.ix + 1})`);
                node.classList.add("active");

                // unmark marked nodes
                for (const node of this.section.querySelectorAll("char.marked")) {
                    node.classList.remove("marked");
                }

                if (this.anchor !== null) {
                    // anchor is set, lets mark nodes between anchor and
                    // active node
                    let marked = 0;
                    const nodes = this.section.querySelectorAll(`char:nth-child(n + ${this.anchor + 1})`);
                    for (const node of nodes) {
                        node.classList.add("marked");
                        marked += 1;
                        if (marked > this.ix - this.anchor) {
                            break;
                        }
                    }
                }

                // set form elements
                this.indexSpan.innerHTML = this.ix;
                this.counterSpan.innerHTML = this.probeCount;
            }

            markSpan(span) {
                // unmark marked nodes
                for (const node of this.section.querySelectorAll("char.marked")) {
                    node.classList.remove("marked");
                }

                const [spanStart, spanEnd] = span;
                const nodes = this.section.querySelectorAll(`char:nth-child(n + ${spanStart + 1})`);
                let marked = 0;
                for (const node of nodes) {
                    node.classList.add("final");
                    marked += 1;
                    if (marked > spanEnd - spanStart) {
                        break;
                    }
                }
            }

            next() {
                if (this.text.length > this.ix + 1) {
                    this.ix += 1;
                    this.probeCount += 1;
                    const [newAnchor, span] = (this.parseFn)(this.ix, this.anchor, this.text);
                    this.anchor = newAnchor;
                    if (span !== null) {
                        this.markSpan(span);
                    }
                }
                this.updateUI();
            }

            reset() {
                // unmark marked nodes
                for (const node of this.section.querySelectorAll("char.final")) {
                    node.classList.remove("final");
                }

                this.ix = 0;
                this.probeCount = 0;
                this.parseFn = this.parseFnGen();
                this.updateUI();
            }

            autoplay() {
                const self = this;
                this.next();
                if (this.text.length > this.ix + 1) {
                    setTimeout(() => self.autoplay(), this.autoplayDelayMs);
                }
            }
        }
    
        window.addEventListener("DOMContentLoaded", () => {
            new Demo(
                document.getElementsByTagName("demo")[0],
                "HelloÂ *world*!",
                () => {
                    let inside = false;

                    // parseFn takes the current ix, anchor and text
                    // and returns an anchor and a span
                    return (ix, anchor, text) => {
                        if (text[ix] == '*') {
                            if (inside) {
                                return [null, [anchor, ix]];
                            } else {
                                inside = true;
                                return [ix, null];
                            }
                            
                        }

                        return [anchor, null];
                    }
                }
            );
        });
    </script>
</head>
<body>
    <demo/>
</body>
</html>